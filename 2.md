我本地存在graphql的operation：
const localQuery = `
query SearchProductsAndServices($searchQuery: String!) {
searchResults: search(query: $searchQuery) {
... on Product {
id
name
productPrice: price {
value
currency
discount
}
}
... on Service {
id
name
servicePrice: price {
value
currency
isMemberPrice
}
}
}
}
`
我现在远程存在一个同名的这样一个operation但是他的参数类型不同，返回字段也有一些差别，请使用ast去更新本地这个operation，使用ts语言写工具函数
要使用 TypeScript 创建一个工具函数修改 GraphQL 操作，你可以使用 `graphql` 库（https://www.npmjs.com/package/graphql）来解析和转换 GraphQL 文档。以下是一个示例工具函数，用于将本地操作更新为指定的远程操作，参数类型和返回字段可能有所不同：

首先，请安装 `graphql` 库:

```sh
npm install graphql
```

然后编写如下 TypeScript 函数:

```typescript
import {
  parse,
  print,
  FieldNode,
  OperationDefinitionNode,
  DefinitionNode,
  visit,
  DocumentNode,
} from "graphql";

// 使用类型别名简化类型定义
type UpdateInfo = {
  paramName: string;
  newParamType: string;
  fieldToUpdate: string;
  updatedField: string;
};

// 将本地查询更新为远程查询
function updateLocalOperation(
  localOperation: string,
  remoteOperation: string,
  updateInfo: UpdateInfo
): string {
  // 解析本地和远程查询
  const localAst: DocumentNode = parse(localOperation);
  const remoteAst: DocumentNode = parse(remoteOperation);

  // 使用visitor模式遍历并更新AST
  const updatedAst: DocumentNode = visit(localAst, {
    OperationDefinition: {
      enter(node: OperationDefinitionNode) {
        node.variableDefinitions?.forEach((variableDefinition) => {
          if (variableDefinition.variable.name.value === updateInfo.paramName) {
            const matchingVariable = remoteAst.definitions
              .flatMap((def: DefinitionNode) =>
                "variableDefinitions" in def ? def.variableDefinitions : []
              )
              .find(
                (remoteVarDef) =>
                  remoteVarDef.variable.name.value === updateInfo.paramName
              );

            if (matchingVariable) {
              variableDefinition.type = matchingVariable.type;
            }
          }
        });
      },
    },
    Field: {
      enter(node: FieldNode) {
        if (node.name.value === updateInfo.fieldToUpdate) {
          const matchingField = remoteAst.definitions
            .flatMap((def: DefinitionNode) =>
              "selectionSet" in def
                ? def.selectionSet.selections.flatMap((field: FieldNode) =>
                    field.name.value === updateInfo.fieldToUpdate
                      ? [field]
                      : []
                  )
                : []
            )
            .find((remoteField) => remoteField.name.value === updateInfo.fieldToUpdate);

          if (matchingField) {
            node.selectionSet = matchingField.selectionSet;
          }
        }

        if (node.alias && node.alias.value === updateInfo.fieldToUpdate) {
          node.alias.value = updateInfo.updatedField;
        }
      },
    },
  });

  // 生成并返回更新的操作字符串
  return print(updatedAst);
}
```

现在可以使用这个 `updateLocalOperation` 函数根据提供的远程查询和字段映射信息更新本地查询。例如：

```typescript
const remoteQuery = ...
const updateInfo = {
  paramName: "searchQuery",
  newParamType: "RemoteSearchQuery!",
  fieldToUpdate: "servicePrice",
  updatedField: "remoteServicePrice",
};

const updatedLocalQuery = updateLocalOperation(localQuery, remoteQuery, updateInfo);
```

如果我本地还存在其他各种各样的operations，我需要你实现一个通用工具函数。本地字段在远程不存在就删除，本地字段有别名和自定义指令保留别名和自定义指令，远程比本地多的字段就添加到本地。

要创建一个通用工具函数，可以遵循以下步骤：

1. 从本地查询中查找并删除不存在于远程查询中的字段。
2. 更新本地Operation中的参数类型。
3. 保留本地查询中的别名和自定义指令。
4. 将本地缺失的远程字段添加到本地查询。

以下是该工具函数的TypeScript实现：

```typescript
import {
  parse,
  print,
  OperationDefinitionNode,
  DefinitionNode,
  FieldNode,
  DocumentNode,
  visit,
} from "graphql";

// 对本地查询进行更新以使其与远程查询一致
function syncLocalOperation(
  localOperation: string,
  remoteOperation: string
): string {
  /* 解析本地和远程查询 */
  const localAst: DocumentNode = parse(localOperation);
  const remoteAst: DocumentNode = parse(remoteOperation);

  /* 定义用于AST节点比较的辅助函数 */
  function fieldNameEquals(a: FieldNode, b: FieldNode): boolean {
    return (
      (!a.alias && a.name.value === b.name.value) ||
      (a.alias && a.alias.value === b.name.value)
    );
  }

  /* 使用visitor模式遍历并更新AST */
  const updatedAst: DocumentNode = visit(localAst, {
    OperationDefinition: {
      enter(node: OperationDefinitionNode) {
        // 更新变量定义
        node.variableDefinitions?.forEach((variableDefinition) => {
          const matchingVariable = remoteAst.definitions
            .flatMap((def: DefinitionNode) =>
              "variableDefinitions" in def ? def.variableDefinitions : []
            )
            .find(
              (remoteVarDef) =>
                remoteVarDef.variable.name.value ===
                variableDefinition.variable.name.value
            );

          if (matchingVariable) {
            variableDefinition.type = matchingVariable.type;
          }
        });

        // 遍历节点的选择集
        node.selectionSet?.selections.forEach((field, index, selections) => {
          const matchingField = remoteAst.definitions
            .flatMap((def: DefinitionNode) =>
              "selectionSet" in def ? def.selectionSet.selections : []
            )
            .find((remoteField: FieldNode) => fieldNameEquals(field as FieldNode, remoteField));

          if (!matchingField) {
            // 删除不存在于远程查询中的字段
            selections.splice(index, 1);
          }
        });

        // 添加本地查询中缺失的字段
        remoteAst.definitions
          .flatMap((def: DefinitionNode) =>
            "selectionSet" in def ? def.selectionSet.selections : []
          )
          .forEach((remoteField) => {
            const hasMatchingField = node.selectionSet.selections.some(
              (field) => fieldNameEquals(field as FieldNode, remoteField as FieldNode)
            );

            if (!hasMatchingField) {
              node.selectionSet.selections.push(remoteField);
            }
          });
      },
    },
    Field: {
      enter(node: FieldNode) {
        const matchingField = remoteAst.definitions
          .flatMap((def: DefinitionNode) =>
            "selectionSet" in def ? def.selectionSet.selections : []
          )
          .find((remoteField: FieldNode) => fieldNameEquals(node, remoteField));

        if (matchingField) {
          // 更新字段的选择集（包括子字段）
          node.selectionSet = matchingField.selectionSet;

          // 保留别名和自定义指令（如果有）
          if (node.alias) {
            matchingField.alias = node.alias;
          }
          if (node.directives) {
            matchingField.directives = node.directives;
          }
        }
      },
    },
  });

  // 生成并返回更新的操作字符串
  return print(updatedAst);
}
```

现在可以使用这个 `syncLocalOperation` 函数来根据提供的远程查询同步本地查询。例如：

```typescript
const remoteQuery = ...
const syncedLocalQuery = syncLocalOperation(localQuery, remoteQuery);
```

这个函数将根据远程查询自动更新本地查询的参数类型、添加缺失的字段、删除多余的字段，并保留别名和自定义指令。

如果我本地还存在 聚合多个kind是Field类型的 operation，我也需要对这种gql实现更新，但是要考虑参数名称改变万一导致冲突的情况
为了处理这种情况，我们将在`syncLocalOperation`函数中添加一个检查步骤。我们需要在更新参数名称和类型时检查是否存在重名参数。以下是修改后的工具函数：

```typescript
// 在更新参数类型时检查是否存在重名参数
function findNonConflictingParamName(
  paramName: string,
  remoteVarDefs: ReadonlyArray<VariableDefinitionNode>,
  localVarDefs: ReadonlyArray<VariableDefinitionNode>
): string {
  let updatedName = paramName;
  let i = 1;

  const remoteParamNames = remoteVarDefs.map((def) => def.variable.name.value);
  const localParamNames = localVarDefs.map((def) => def.variable.name.value);

  while (remoteParamNames.includes(updatedName) || localParamNames.includes(updatedName)) {
    updatedName = `${paramName}_${i}`;
    i++;
  }

  return updatedName;
}

function syncLocalOperation(
  localOperation: string,
  remoteOperation: string
): string {
  // ... previous code ...
  const updatedAst: DocumentNode = visit(localAst, {
    // ... previous code ...
    OperationDefinition: {
      enter(node: OperationDefinitionNode) {
        // 更新变量定义
        node.variableDefinitions?.forEach((variableDefinition) => {
          const remoteVarDef = remoteAst.definitions
            .flatMap((def: DefinitionNode) =>
              "variableDefinitions" in def ? def.variableDefinitions : []
            )
            .find(
              (remoteVarDef) =>
                remoteVarDef.variable.name.value ===
                variableDefinition.variable.name.value
            );

          if (remoteVarDef) {
            variableDefinition.type = remoteVarDef.type;
          } else {
            const newName = findNonConflictingParamName(
              variable

我本地和远程可能存在层级多层的字段，我自己也不知道会定义多少层，所以我需要你的工具函数更加通用

为了让工具函数更通用，可以对syncLocalOperation进行递归更新，以处理多层嵌套的字段。以下是更新后的递归syncLocalOperation：

```typescript
import {
  parse,
  print,
  DocumentNode,
  OperationDefinitionNode,
  FieldNode,
  VariableDefinitionNode,
  SelectionSetNode,
  visit,
} from "graphql";

function findNonConflictingParamName(
  paramName: string,
  remoteVarDefs: ReadonlyArray<VariableDefinitionNode>,
  localVarDefs: ReadonlyArray<VariableDefinitionNode>
): string {
  let updatedName = paramName;
  let i = 1;

  const remoteParamNames = remoteVarDefs.map((def) => def.variable.name.value);
  const localParamNames = localVarDefs.map((def) => def.variable.name.value);

  while (remoteParamNames.includes(updatedName) || localParamNames.includes(updatedName)) {
    updatedName = `${paramName}_${i}`;
    i++;
  }

  return updatedName;
}

function syncSelectionSet(
  localSelectionSet: SelectionSetNode,
  remoteSelectionSet: SelectionSetNode
) {
  // 遍历本地查询的选择集
  localSelectionSet.selections.forEach((localField, index) => {
    if (localField.kind !== "Field") return;

    const remoteField = remoteSelectionSet.selections.find(
      (remoteField) =>
        remoteField.kind === "Field" && localField.name.value === remoteField.name.value
    );

    if (!remoteField) {
      // 删除本地查询中不存在于远程查询的字段
      localSelectionSet.selections.splice(index, 1);
    } else {
      syncLocalOperation(localField, remoteField as FieldNode);
    }
  });

  // 将远程查询中缺失的字段添加到本地查询
  remoteSelectionSet.selections.forEach((remoteField) => {
    if (remoteField.kind !== "Field") return;

    const localField = localSelectionSet.selections.find(
      (localField) =>
        localField.kind === "Field" && remoteField.name.value === localField.name.value
    );

    if (!localField) {
      localSelectionSet.selections.push(remoteField);
    }
  });
}

function syncLocalOperation(
  localAst: DocumentNode | FieldNode,
  remoteAst: DocumentNode | FieldNode
) {
  visit(localAst, {
    OperationDefinition: {
      enter(node: OperationDefinitionNode) {
        // 遍历并更新变量定义
        node.variableDefinitions?.forEach((variableDefinition) => {
          const remoteVarDef = remoteAst.variableDefinitions.find(
            (remoteVarDef) =>
              remoteVarDef.variable.name.value === variableDefinition.variable.name.value
          );

          if (remoteVarDef) {
            variableDefinition.type = remoteVarDef.type;
          } else {
            const newName = findNonConflictingParamName(
              variableDefinition.variable.name.value,
              remoteAst.variableDefinitions,
              node.variableDefinitions
            );
            variableDefinition.variable.name.value = newName;
          }
        });

        // 同的嵌套字段，并且会逐层递归处理。
        ```
        
继续上面的实现，补充完整给我
同步本地嵌套字段，并且会逐层递归处理。请参阅下面的完整实现：

```ts
import {
  parse,
  print,
  DocumentNode,
  OperationDefinitionNode,
  FieldNode,
  VariableDefinitionNode,
  SelectionSetNode,
  visit,
} from "graphql";

function findNonConflictingParamName(
  paramName: string,
  remoteVarDefs: ReadonlyArray<VariableDefinitionNode>,
  localVarDefs: ReadonlyArray<VariableDefinitionNode>
): string {
  let updatedName = paramName;
  let i = 1;

  const remoteParamNames = remoteVarDefs.map((def) => def.variable.name.value);
  const localParamNames = localVarDefs.map((def) => def.variable.name.value);

  while (remoteParamNames.includes(updatedName) || localParamNames.includes(updatedName)) {
    updatedName = `${paramName}_${i}`;
    i++;
  }

  return updatedName;
}

function syncSelectionSet(
  localSelectionSet: SelectionSetNode,
  remoteSelectionSet: SelectionSetNode
) {
  // 遍历本地查询的选择集
  localSelectionSet.selections.forEach((localField, index) => {
    if (localField.kind !== "Field") return;

    const remoteField = remoteSelectionSet.selections.find(
      (remoteField) =>
        remoteField.kind === "Field" && localField.name.value === remoteField.name.value
    );

    if (!remoteField) {
      // 删除本地查询中不存在于远程查询的字段
      localSelectionSet.selections.splice(index, 1);
    } else {
      syncLocalOperation(localField, remoteField as FieldNode);
    }
  });

  // 将远程查询中缺失的字段添加到本地查询
  remoteSelectionSet.selections.forEach((remoteField) => {
    if (remoteField.kind !== "Field") return;

    const localField = localSelectionSet.selections.find(
      (localField) =>
        localField.kind === "Field" && remoteField.name.value === localField.name.value
    );

    if (!localField) {
      localSelectionSet.selections.push(remoteField);
    }
  });
}

function syncLocalField(localField: FieldNode, remoteField: FieldNode) {
  // 同步本地和远程选择集
  if (localField.selectionSet && remoteField.selectionSet) {
    syncSelectionSet(localField.selectionSet, remoteField.selectionSet);
  } else if (!localField.selectionSet && remoteField.selectionSet) {
    localField.selectionSet = remoteField.selectionSet;
  }

  // 保留别名和自定义指令（如果有）
  if (localField.alias) {
    remoteField.alias = localField.alias;
  }
  if (localField.directives) {
    remoteField.directives = localField.directives;
  }
}

function syncLocalOperation(
  localAst: DocumentNode | FieldNode,
  remoteAst: DocumentNode | FieldNode
) {
  visit(localAst, {
    OperationDefinition: {
      enter(node: OperationDefinitionNode) {
        // 遍历并更新变量定义
        node.variableDefinitions?.forEach((variableDefinition) => {
          const remoteVarDef = remoteAst.variableDefinitions.find(
            (remoteVarDef) =>
              remoteVarDef.variable.name.value === variableDefinition.variable.name.value
          );

          if (remoteVarDef) {
            variableDefinition.type = remoteVarDef.type;
          } else {
            const newName = findNonConflictingParamName(
              variableDefinition.variable.name.value,
              remoteAst.variableDefinitions,
              node.variableDefinitions
            );
            variableDefinition.variable.name.value = newName;
          }
        });

        syncSelectionSet(node.selectionSet, remoteAst.selectionSet);
      },
    },
    Field: {
      enter(localField: FieldNode) {
        if (remoteAst.kind !== 'Field') return;
        
        const remoteField = remoteAst;
        syncLocalField(localField, remoteField);
      },
    },
  });
}

const localDoc: DocumentNode = parse(localOperation);
const remoteDoc: DocumentNode = parse(remoteOperation);
syncLocalOperation(localDoc, remoteDoc);
const updatedLocalOperation = print(localDoc);
```

此实现包括`syncLocalField`函数，用于同步本地与远程Field，并递归地处理其子Field。`syncLocalOperation`函数用于同时处理`DocumentNode`和`FieldNode`，为了递归处理Field。最后，我们对文档和打印操作进行解析和转换，并返回已更新的本地操作字符串。